while (thenUnit != commonSucc) { // the meet point not reached yet
                    while(cfg.getNormalSuccessors(thenUnit).size() > 1 && thenUnit != commonSucc && canVeritest) {  //TODO: Support exceptionalSuccessors in the future
                        if (VeritestingListener.veritestingMode < 2) {
                            canVeritest = false;
                            break;
                        }
                        //instead of giving up, try to compute a summary of everything from thenUnit up to commonSucc
                        //to allow complex regions

                        HashMap<Expression, Expression> savedHoleHashMap = saveHoleHashMap();
                        HashMap<String, Expression> savedVarCache = saveVarCache();

                        // recursive call to doAnalysis to try to summarize the inner region
                        doAnalysis(thenUnit, commonSucc);
                        varUtil.holeHashMap.putAll(savedHoleHashMap); //restore holeHashMap
                        varUtil.varCache.putAll(savedVarCache);
                        int offset = ((IBytecodeMethod) (ir.getMethod())).getBytecodeIndex(thenUnit.getLastInstructionIndex());
                        String key = currentClassName + "." + currentMethodName + methodSig + "#" + offset;

                        // MWW: working with child region here
                        if(VeritestingListener.veritestingRegions.containsKey(key)) { // we are able to summarize the inner region, try to sallow it
                            System.out.println("Veritested inner region with key = " + key);
                            //visit all instructions up to and including the condition
                            BlockSummary blockSummary = new BlockSummary(thenUnit, thenExpr, canVeritest).invoke();
                            canVeritest = blockSummary.isCanVeritest();
                            thenExpr = blockSummary.getExpression(); // outer region thenExpr
                            Expression conditionExpression = blockSummary.getIfExpression();
                            //cannot handle returns inside a if-then-else
                            if(blockSummary.getIsExitNode()) canVeritest = false;
                            if(!canVeritest) break;
                            ISSABasicBlock commonSuccthenUnit = cfg.getIPdom(thenUnit.getNumber());

                            //invariant: outer region meetpoint postdominate inner region meet point
                            NumberedGraph<ISSABasicBlock> invertedCFG = GraphInverter.invert(cfg);
                            NumberedDominators<ISSABasicBlock> postDom = (NumberedDominators<ISSABasicBlock>)
                                    Dominators.make(invertedCFG, cfg.exit());
                            boolean bPostDom = (postDom.isDominatedBy(commonSuccthenUnit, commonSucc));
                            assert(bPostDom);
                            //start swallow holes from inner region to the outer region by taking a copy of the inner holes to the outer region
                            VeritestingRegion innerRegion = VeritestingListener.veritestingRegions.get(key);

                            // MWW: new code.  Note: really exception should never occur, so perhaps this is *too*
                            // defensive.
                            try {
                                assert(conditionExpression != null);
                                SPFCaseList innerCases = innerRegion.getSpfCases().cloneEmbedPathConstraint(conditionExpression);
                                varUtil.getSpfCases().addAll(innerCases);
                            } catch (StaticRegionException sre) {
                                System.out.println("Unable to instantiate spfCases: " + sre.toString());
                                canVeritest = false;
                                break;
                            }
                            // MWW: end of new code

                            for(Expression e: innerRegion.getOutputVars()) {
                                varUtil.defLocalVars.add(e);
                            }
                            for(Map.Entry<Expression, Expression> entry: innerRegion.getHoleHashMap().entrySet()) {
                                varUtil.holeHashMap.put(entry.getKey(), entry.getValue());
                                if(((HoleExpression)entry.getKey()).getHoleType() == HoleExpression.HoleType.CONDITION ||
                                        ((HoleExpression)entry.getKey()).getHoleType() == HoleExpression.HoleType.NEGCONDITION)
                                    varUtil.holeHashMap.remove(entry.getKey());
                            }
                            Expression thenExpr1 = innerRegion.getSummaryExpression();
                            thenExpr1 = replaceCondition(thenExpr1, conditionExpression);
                            if (thenExpr1 != null) {
                                if (thenExpr != null)
                                    thenExpr =
                                            new Operation(Operation.Operator.AND,
                                                    thenExpr, thenExpr1);
                                else thenExpr = thenExpr1;
                            }
                            thenPred = null;
                            thenUnit = commonSuccthenUnit;
                            summarizedRegionStartBB.addAll(innerRegion.summarizedRegionStartBB);
                        } else canVeritest = false;
                    }
                    if (!canVeritest || thenUnit == commonSucc) break;
                    BlockSummary blockSummary = new BlockSummary(thenUnit, thenExpr, canVeritest, thenPLAssignSPF).invoke();
                    canVeritest = blockSummary.isCanVeritest();
                    thenExpr = blockSummary.getExpression();
                    //we should not encounter a BB with more than one successor at this point
                    assert(blockSummary.getIfExpression() == null);
                    //cannot handle returns inside a if-then-else
                    if(blockSummary.getIsExitNode()) canVeritest = false;
                    if (!canVeritest) break;
                    thenPred = thenUnit;
                    thenUnit = cfg.getNormalSuccessors(thenUnit).iterator().next();
                    if (thenUnit == endingUnit) break;
                }
